// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: onnx.proto3
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// WARNING: This file is automatically generated!  Please edit onnx.in.proto.

// SPDX-License-Identifier: Apache-2.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Versioning
///
/// ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
///
/// To be compatible with both proto2 and proto3, we will use a version number
/// that is not defined by the default value but an explicit enum number.
enum Onnx_Version: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// proto3 requires the first enum value to be zero.
  /// We add this just to appease the compiler.
  case startVersion // = 0

  /// The version field is always serialized and we will use it to store the
  /// version that the  graph is generated from. This helps us set up version
  /// control.
  /// For the IR, we are using simple numbers starting with 0x00000001,
  /// which was the version we published on Oct 10, 2017.
  case irVersion20171010 // = 1

  /// IR_VERSION 2 published on Oct 30, 2017
  /// - Added type discriminator to AttributeProto to support proto3 users
  case irVersion20171030 // = 2

  /// IR VERSION 3 published on Nov 3, 2017
  /// - For operator versioning:
  ///    - Added new message OperatorSetIdProto
  ///    - Added opset_import in ModelProto
  /// - For vendor extensions, added domain in NodeProto
  case irVersion2017113 // = 3

  /// IR VERSION 4 published on Jan 22, 2019
  /// - Relax constraint that initializers should be a subset of graph inputs
  /// - Add type BFLOAT16
  case irVersion2019122 // = 4

  /// IR VERSION 5 published on March 18, 2019
  /// - Add message TensorAnnotation.
  /// - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
  case irVersion2019318 // = 5

  /// IR VERSION 6 published on Sep 19, 2019
  /// - Add support for sparse tensor constants stored in model.
  ///   - Add message SparseTensorProto
  ///   - Add sparse initializers
  case irVersion2019919 // = 6

  /// IR VERSION 7 published on May 8, 2020
  /// - Add support to allow function body graph to rely on multiple external opreator sets.
  /// - Add a list to promote inference graph's initializers to global and
  ///   mutable variables. Global variables are visible in all graphs of the
  ///   stored models.
  /// - Add message TrainingInfoProto to store initialization
  ///   method and training algorithm. The execution of TrainingInfoProto
  ///   can modify the values of mutable variables.
  /// - Implicitly add inference graph into each TrainingInfoProto's algorithm.
  case irVersion202058 // = 7

  /// IR VERSION 8 published on <TBD>
  /// Introduce TypeProto.SparseTensor
  /// Introduce TypeProto.Optional
  /// Added a list of FunctionProtos local to the model
  /// Deprecated since_version and operator status from FunctionProto
  case irVersion // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .startVersion
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .startVersion
    case 1: self = .irVersion20171010
    case 2: self = .irVersion20171030
    case 3: self = .irVersion2017113
    case 4: self = .irVersion2019122
    case 5: self = .irVersion2019318
    case 6: self = .irVersion2019919
    case 7: self = .irVersion202058
    case 8: self = .irVersion
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .startVersion: return 0
    case .irVersion20171010: return 1
    case .irVersion20171030: return 2
    case .irVersion2017113: return 3
    case .irVersion2019122: return 4
    case .irVersion2019318: return 5
    case .irVersion2019919: return 6
    case .irVersion202058: return 7
    case .irVersion: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Onnx_Version: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Onnx_Version] = [
    .startVersion,
    .irVersion20171010,
    .irVersion20171030,
    .irVersion2017113,
    .irVersion2019122,
    .irVersion2019318,
    .irVersion2019919,
    .irVersion202058,
    .irVersion,
  ]
}

#endif  // swift(>=4.2)

/// Operator/function status.
enum Onnx_OperatorStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case experimental // = 0
  case stable // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .experimental
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .experimental
    case 1: self = .stable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .experimental: return 0
    case .stable: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Onnx_OperatorStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Onnx_OperatorStatus] = [
    .experimental,
    .stable,
  ]
}

#endif  // swift(>=4.2)

/// Attributes
///
/// A named attribute containing either singular float, integer, string, graph,
/// and tensor values, or repeated float, integer, string, graph, and tensor values.
/// An AttributeProto MUST contain the name field, and *only one* of the
/// following content fields, effectively enforcing a C/C++ union equivalent.
struct Onnx_AttributeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name field MUST be present for this version of the IR.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
  /// In this case, this AttributeProto does not contain data, and it's a reference of attribute
  /// in parent scope.
  /// NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
  var refAttrName: String {
    get {return _storage._refAttrName}
    set {_uniqueStorage()._refAttrName = newValue}
  }

  /// A human-readable documentation for this attribute. Markdown is allowed.
  var docString: String {
    get {return _storage._docString}
    set {_uniqueStorage()._docString = newValue}
  }

  /// The type field MUST be present for this version of the IR.
  /// For 0.0.1 versions of the IR, this field was not defined, and
  /// implementations needed to use has_field heuristics to determine
  /// which value field was in use.  For IR_VERSION 0.0.2 or later, this
  /// field MUST be set and match the f|i|s|t|... field in use.  This
  /// change was made to accommodate proto3 implementations.
  var type: Onnx_AttributeProto.AttributeType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Exactly ONE of the following fields must be present for this version of the IR
  var f: Float {
    get {return _storage._f}
    set {_uniqueStorage()._f = newValue}
  }

  /// int
  var i: Int64 {
    get {return _storage._i}
    set {_uniqueStorage()._i = newValue}
  }

  /// UTF-8 string
  var s: Data {
    get {return _storage._s}
    set {_uniqueStorage()._s = newValue}
  }

  /// tensor value
  var t: Onnx_TensorProto {
    get {return _storage._t ?? Onnx_TensorProto()}
    set {_uniqueStorage()._t = newValue}
  }
  /// Returns true if `t` has been explicitly set.
  var hasT: Bool {return _storage._t != nil}
  /// Clears the value of `t`. Subsequent reads from it will return its default value.
  mutating func clearT() {_uniqueStorage()._t = nil}

  /// graph
  var g: Onnx_GraphProto {
    get {return _storage._g ?? Onnx_GraphProto()}
    set {_uniqueStorage()._g = newValue}
  }
  /// Returns true if `g` has been explicitly set.
  var hasG: Bool {return _storage._g != nil}
  /// Clears the value of `g`. Subsequent reads from it will return its default value.
  mutating func clearG() {_uniqueStorage()._g = nil}

  /// sparse tensor value
  var sparseTensor: Onnx_SparseTensorProto {
    get {return _storage._sparseTensor ?? Onnx_SparseTensorProto()}
    set {_uniqueStorage()._sparseTensor = newValue}
  }
  /// Returns true if `sparseTensor` has been explicitly set.
  var hasSparseTensor: Bool {return _storage._sparseTensor != nil}
  /// Clears the value of `sparseTensor`. Subsequent reads from it will return its default value.
  mutating func clearSparseTensor() {_uniqueStorage()._sparseTensor = nil}

  /// Do not use field below, it's deprecated.
  /// optional ValueProto v = 12;         // value - subsumes everything but graph
  var tp: Onnx_TypeProto {
    get {return _storage._tp ?? Onnx_TypeProto()}
    set {_uniqueStorage()._tp = newValue}
  }
  /// Returns true if `tp` has been explicitly set.
  var hasTp: Bool {return _storage._tp != nil}
  /// Clears the value of `tp`. Subsequent reads from it will return its default value.
  mutating func clearTp() {_uniqueStorage()._tp = nil}

  /// list of floats
  var floats: [Float] {
    get {return _storage._floats}
    set {_uniqueStorage()._floats = newValue}
  }

  /// list of ints
  var ints: [Int64] {
    get {return _storage._ints}
    set {_uniqueStorage()._ints = newValue}
  }

  /// list of UTF-8 strings
  var strings: [Data] {
    get {return _storage._strings}
    set {_uniqueStorage()._strings = newValue}
  }

  /// list of tensors
  var tensors: [Onnx_TensorProto] {
    get {return _storage._tensors}
    set {_uniqueStorage()._tensors = newValue}
  }

  /// list of graph
  var graphs: [Onnx_GraphProto] {
    get {return _storage._graphs}
    set {_uniqueStorage()._graphs = newValue}
  }

  /// list of sparse tensors
  var sparseTensors: [Onnx_SparseTensorProto] {
    get {return _storage._sparseTensors}
    set {_uniqueStorage()._sparseTensors = newValue}
  }

  /// list of type protos
  var typeProtos: [Onnx_TypeProto] {
    get {return _storage._typeProtos}
    set {_uniqueStorage()._typeProtos = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Note: this enum is structurally identical to the OpSchema::AttrType
  /// enum defined in schema.h.  If you rev one, you likely need to rev the other.
  enum AttributeType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case undefined // = 0
    case float // = 1
    case int // = 2
    case string // = 3
    case tensor // = 4
    case graph // = 5
    case sparseTensor // = 11
    case typeProto // = 13
    case floats // = 6
    case ints // = 7
    case strings // = 8
    case tensors // = 9
    case graphs // = 10
    case sparseTensors // = 12
    case typeProtos // = 14
    case UNRECOGNIZED(Int)

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .float
      case 2: self = .int
      case 3: self = .string
      case 4: self = .tensor
      case 5: self = .graph
      case 6: self = .floats
      case 7: self = .ints
      case 8: self = .strings
      case 9: self = .tensors
      case 10: self = .graphs
      case 11: self = .sparseTensor
      case 12: self = .sparseTensors
      case 13: self = .typeProto
      case 14: self = .typeProtos
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .float: return 1
      case .int: return 2
      case .string: return 3
      case .tensor: return 4
      case .graph: return 5
      case .floats: return 6
      case .ints: return 7
      case .strings: return 8
      case .tensors: return 9
      case .graphs: return 10
      case .sparseTensor: return 11
      case .sparseTensors: return 12
      case .typeProto: return 13
      case .typeProtos: return 14
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Onnx_AttributeProto.AttributeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Onnx_AttributeProto.AttributeType] = [
    .undefined,
    .float,
    .int,
    .string,
    .tensor,
    .graph,
    .sparseTensor,
    .typeProto,
    .floats,
    .ints,
    .strings,
    .tensors,
    .graphs,
    .sparseTensors,
    .typeProtos,
  ]
}

#endif  // swift(>=4.2)

/// Defines information on value, including the name, the type, and
/// the shape of the value.
struct Onnx_ValueInfoProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This field MUST be present in this version of the IR.
  var name: String = String()

  /// This field MUST be present in this version of the IR for
  /// inputs and outputs of the top-level graph.
  var type: Onnx_TypeProto {
    get {return _type ?? Onnx_TypeProto()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// A human-readable documentation for this value. Markdown is allowed.
  var docString: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: Onnx_TypeProto? = nil
}

/// Nodes
///
/// Computation graphs are made up of a DAG of nodes, which represent what is
/// commonly called a "layer" or "pipeline stage" in machine learning frameworks.
///
/// For example, it can be a node of type "Conv" that takes in an image, a filter
/// tensor and a bias tensor, and produces the convolved output.
struct Onnx_NodeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// namespace Value
  var input: [String] = []

  /// namespace Value
  var output: [String] = []

  /// An optional identifier for this node in a graph.
  /// This field MAY be absent in ths version of the IR.
  var name: String = String()

  /// The symbolic identifier of the Operator to execute.
  var opType: String = String()

  /// The domain of the OperatorSet that specifies the operator named by op_type.
  var domain: String = String()

  /// Additional named attributes.
  var attribute: [Onnx_AttributeProto] = []

  /// A human-readable documentation for this node. Markdown is allowed.
  var docString: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Training information
/// TrainingInfoProto stores information for training a model.
/// In particular, this defines two functionalities: an initialization-step
/// and a training-algorithm-step. Initialization resets the model
/// back to its original state as if no training has been performed.
/// Training algorithm improves the model based on input data.
///
/// The semantics of the initialization-step is that the initializers
/// in ModelProto.graph and in TrainingInfoProto.algorithm are first
/// initialized as specified by the initializers in the graph, and then
/// updated by the "initialization_binding" in every instance in
/// ModelProto.training_info.
///
/// The field "algorithm" defines a computation graph which represents a
/// training algorithm's step. After the execution of a
/// TrainingInfoProto.algorithm, the initializers specified by "update_binding"
/// may be immediately updated. If the targeted training algorithm contains
/// consecutive update steps (such as block coordinate descent methods),
/// the user needs to create a TrainingInfoProto for each step.
struct Onnx_TrainingInfoProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This field describes a graph to compute the initial tensors
  /// upon starting the training process. Initialization graph has no input
  /// and can have multiple outputs. Usually, trainable tensors in neural
  /// networks are randomly initialized. To achieve that, for each tensor,
  /// the user can put a random number operator such as RandomNormal or
  /// RandomUniform in TrainingInfoProto.initialization.node and assign its
  /// random output to the specific tensor using "initialization_binding".
  /// This graph can also set the initializers in "algorithm" in the same
  /// TrainingInfoProto; a use case is resetting the number of training
  /// iteration to zero.
  ///
  /// By default, this field is an empty graph and its evaluation does not
  /// produce any output. Thus, no initializer would be changed by default.
  var initialization: Onnx_GraphProto {
    get {return _storage._initialization ?? Onnx_GraphProto()}
    set {_uniqueStorage()._initialization = newValue}
  }
  /// Returns true if `initialization` has been explicitly set.
  var hasInitialization: Bool {return _storage._initialization != nil}
  /// Clears the value of `initialization`. Subsequent reads from it will return its default value.
  mutating func clearInitialization() {_uniqueStorage()._initialization = nil}

  /// This field represents a training algorithm step. Given required inputs,
  /// it computes outputs to update initializers in its own or inference graph's
  /// initializer lists. In general, this field contains loss node, gradient node,
  /// optimizer node, increment of iteration count.
  ///
  /// An execution of the training algorithm step is performed by executing the
  /// graph obtained by combining the inference graph (namely "ModelProto.graph")
  /// and the "algorithm" graph. That is, the actual the actual
  /// input/initializer/output/node/value_info/sparse_initializer list of
  /// the training graph is the concatenation of
  /// "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
  /// and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
  /// in that order. This combined graph must satisfy the normal ONNX conditions.
  /// Now, let's provide a visualization of graph combination for clarity.
  /// Let the inference graph (i.e., "ModelProto.graph") be
  ///    tensor_a, tensor_b -> MatMul -> tensor_c -> Sigmoid -> tensor_d
  /// and the "algorithm" graph be
  ///    tensor_d -> Add -> tensor_e
  /// The combination process results
  ///    tensor_a, tensor_b -> MatMul -> tensor_c -> Sigmoid -> tensor_d -> Add -> tensor_e
  ///
  /// Notice that an input of a node in the "algorithm" graph may reference the
  /// output of a node in the inference graph (but not the other way round). Also, inference
  /// node cannot reference inputs of "algorithm". With these restrictions, inference graph
  /// can always be run independently without training information.
  ///
  /// By default, this field is an empty graph and its evaluation does not
  /// produce any output. Evaluating the default training step never
  /// update any initializers.
  var algorithm: Onnx_GraphProto {
    get {return _storage._algorithm ?? Onnx_GraphProto()}
    set {_uniqueStorage()._algorithm = newValue}
  }
  /// Returns true if `algorithm` has been explicitly set.
  var hasAlgorithm: Bool {return _storage._algorithm != nil}
  /// Clears the value of `algorithm`. Subsequent reads from it will return its default value.
  mutating func clearAlgorithm() {_uniqueStorage()._algorithm = nil}

  /// This field specifies the bindings from the outputs of "initialization" to
  /// some initializers in "ModelProto.graph.initializer" and
  /// the "algorithm.initializer" in the same TrainingInfoProto.
  /// See "update_binding" below for details.
  ///
  /// By default, this field is empty and no initializer would be changed
  /// by the execution of "initialization".
  var initializationBinding: [Onnx_StringStringEntryProto] {
    get {return _storage._initializationBinding}
    set {_uniqueStorage()._initializationBinding = newValue}
  }

  /// Gradient-based training is usually an iterative procedure. In one gradient
  /// descent iteration, we apply
  ///
  /// x = x - r * g
  ///
  /// where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
  /// gradient of "x" with respect to a chosen loss. To avoid adding assignments
  /// into the training graph, we split the update equation into
  ///
  /// y = x - r * g
  /// x = y
  ///
  /// The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
  /// tell that "y" should be assigned to "x", the field "update_binding" may
  /// contain a key-value pair of strings, "x" (key of StringStringEntryProto)
  /// and "y" (value of StringStringEntryProto).
  /// For a neural network with multiple trainable (mutable) tensors, there can
  /// be multiple key-value pairs in "update_binding".
  ///
  /// The initializers appears as keys in "update_binding" are considered
  /// mutable variables. This implies some behaviors
  /// as described below.
  ///
  ///  1. We have only unique keys in all "update_binding"s so that two
  ///     variables may not have the same name. This ensures that one
  ///     variable is assigned up to once.
  ///  2. The keys must appear in names of "ModelProto.graph.initializer" or
  ///     "TrainingInfoProto.algorithm.initializer".
  ///  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
  ///  4. Mutable variables are initialized to the value specified by the
  ///     corresponding initializer, and then potentially updated by
  ///     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
  ///
  /// This field usually contains names of trainable tensors
  /// (in ModelProto.graph), optimizer states such as momentums in advanced
  /// stochastic gradient methods (in TrainingInfoProto.graph),
  /// and number of training iterations (in TrainingInfoProto.graph).
  ///
  /// By default, this field is empty and no initializer would be changed
  /// by the execution of "algorithm".
  var updateBinding: [Onnx_StringStringEntryProto] {
    get {return _storage._updateBinding}
    set {_uniqueStorage()._updateBinding = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Models
///
/// ModelProto is a top-level file/container format for bundling a ML model and
/// associating its computation graph with metadata.
///
/// The semantics of the model are described by the associated GraphProto's.
struct Onnx_ModelProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the IR this model targets. See Version enum above.
  /// This field MUST be present.
  var irVersion: Int64 {
    get {return _storage._irVersion}
    set {_uniqueStorage()._irVersion = newValue}
  }

  /// The OperatorSets this model relies on.
  /// All ModelProtos MUST have at least one entry that
  /// specifies which version of the ONNX OperatorSet is
  /// being imported.
  ///
  /// All nodes in the ModelProto's graph will bind against the operator
  /// with the same-domain/same-op_type operator with the HIGHEST version
  /// in the referenced operator sets.
  var opsetImport: [Onnx_OperatorSetIdProto] {
    get {return _storage._opsetImport}
    set {_uniqueStorage()._opsetImport = newValue}
  }

  /// The name of the framework or tool used to generate this model.
  /// This field SHOULD be present to indicate which implementation/tool/framework
  /// emitted the model.
  var producerName: String {
    get {return _storage._producerName}
    set {_uniqueStorage()._producerName = newValue}
  }

  /// The version of the framework or tool used to generate this model.
  /// This field SHOULD be present to indicate which implementation/tool/framework
  /// emitted the model.
  var producerVersion: String {
    get {return _storage._producerVersion}
    set {_uniqueStorage()._producerVersion = newValue}
  }

  /// Domain name of the model.
  /// We use reverse domain names as name space indicators. For example:
  /// `com.facebook.fair` or `com.microsoft.cognitiveservices`
  ///
  /// Together with `model_version` and GraphProto.name, this forms the unique identity of
  /// the graph.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// The version of the graph encoded. See Version enum below.
  var modelVersion: Int64 {
    get {return _storage._modelVersion}
    set {_uniqueStorage()._modelVersion = newValue}
  }

  /// A human-readable documentation for this model. Markdown is allowed.
  var docString: String {
    get {return _storage._docString}
    set {_uniqueStorage()._docString = newValue}
  }

  /// The parameterized graph that is evaluated to execute the model.
  var graph: Onnx_GraphProto {
    get {return _storage._graph ?? Onnx_GraphProto()}
    set {_uniqueStorage()._graph = newValue}
  }
  /// Returns true if `graph` has been explicitly set.
  var hasGraph: Bool {return _storage._graph != nil}
  /// Clears the value of `graph`. Subsequent reads from it will return its default value.
  mutating func clearGraph() {_uniqueStorage()._graph = nil}

  /// Named metadata values; keys should be distinct.
  var metadataProps: [Onnx_StringStringEntryProto] {
    get {return _storage._metadataProps}
    set {_uniqueStorage()._metadataProps = newValue}
  }

  /// Training-specific information. Sequentially executing all stored
  /// `TrainingInfoProto.algorithm`s and assigning their outputs following
  /// the corresponding `TrainingInfoProto.update_binding`s is one training
  /// iteration. Similarly, to initialize the model
  /// (as if training hasn't happened), the user should sequentially execute
  /// all stored `TrainingInfoProto.initialization`s and assigns their outputs
  /// using `TrainingInfoProto.initialization_binding`s.
  ///
  /// If this field is empty, the training behavior of the model is undefined.
  var trainingInfo: [Onnx_TrainingInfoProto] {
    get {return _storage._trainingInfo}
    set {_uniqueStorage()._trainingInfo = newValue}
  }

  /// A list of function protos local to the model.
  ///
  /// Name of the function "FunctionProto.name" should be unique within the domain "FunctionProto.domain".
  /// In case of any conflicts the behavior (whether the model local functions are given higher priority,
  /// or standard opserator sets are given higher priotity or this is treated as error) is defined by 
  /// the runtimes.
  /// 
  /// The operator sets imported by FunctionProto should be compatible with the ones
  /// imported by ModelProto and other model local FunctionProtos. 
  /// Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto 
  /// or by 2 FunctionProtos then versions for the operator set may be different but, 
  /// the operator schema returned for op_type, domain, version combination
  /// for both the versions should be same for every node in the function body.
  ///
  /// One FunctionProto can reference other FunctionProto in the model, however, recursive reference
  /// is not allowed.
  var functions: [Onnx_FunctionProto] {
    get {return _storage._functions}
    set {_uniqueStorage()._functions = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// StringStringEntryProto follows the pattern for cross-proto-version maps.
/// See https://developers.google.com/protocol-buffers/docs/proto3#maps
struct Onnx_StringStringEntryProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Onnx_TensorAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tensorName: String = String()

  /// <key, value> pairs to annotate tensor specified by <tensor_name> above.
  /// The keys used in the mapping below must be pre-defined in ONNX spec.
  /// For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
  /// quantization parameter keys.
  var quantParameterTensorNames: [Onnx_StringStringEntryProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Graphs
///
/// A graph defines the computational logic of a model and is comprised of a parameterized
/// list of nodes that form a directed acyclic graph based on their inputs and outputs.
/// This is the equivalent of the "network" or "graph" in many deep learning
/// frameworks.
struct Onnx_GraphProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nodes in the graph, sorted topologically.
  var node: [Onnx_NodeProto] = []

  /// The name of the graph.
  var name: String = String()

  /// A list of named tensor values, used to specify constant inputs of the graph.
  /// Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
  /// The name MUST be unique across both initializer and sparse_initializer,
  /// but the name MAY also appear in the input list.
  var initializer: [Onnx_TensorProto] = []

  /// Initializers (see above) stored in sparse format.
  var sparseInitializer: [Onnx_SparseTensorProto] = []

  /// A human-readable documentation for this graph. Markdown is allowed.
  var docString: String = String()

  /// The inputs and outputs of the graph.
  var input: [Onnx_ValueInfoProto] = []

  var output: [Onnx_ValueInfoProto] = []

  /// Information for the values in the graph. The ValueInfoProto.name's
  /// must be distinct. It is optional for a value to appear in value_info list.
  var valueInfo: [Onnx_ValueInfoProto] = []

  /// This field carries information to indicate the mapping among a tensor and its
  /// quantization parameter tensors. For example:
  /// For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
  /// which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
  var quantizationAnnotation: [Onnx_TensorAnnotation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Tensors
///
/// A serialized tensor value.
struct Onnx_TensorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The shape of the tensor.
  var dims: [Int64] = []

  /// The data type of the tensor.
  /// This field MUST have a valid TensorProto.DataType value
  var dataType: Int32 = 0

  var segment: Onnx_TensorProto.Segment {
    get {return _segment ?? Onnx_TensorProto.Segment()}
    set {_segment = newValue}
  }
  /// Returns true if `segment` has been explicitly set.
  var hasSegment: Bool {return self._segment != nil}
  /// Clears the value of `segment`. Subsequent reads from it will return its default value.
  mutating func clearSegment() {self._segment = nil}

  /// For float and complex64 values
  /// Complex64 tensors are encoded as a single array of floats,
  /// with the real components appearing in odd numbered positions,
  /// and the corresponding imaginary component appearing in the
  /// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
  /// is encoded as [1.0, 2.0 ,3.0 ,4.0]
  /// When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
  var floatData: [Float] = []

  /// For int32, uint8, int8, uint16, int16, bool, and float16 values
  /// float16 values must be bit-wise converted to an uint16_t prior
  /// to writing to the buffer.
  /// When this field is present, the data_type field MUST be
  /// INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
  var int32Data: [Int32] = []

  /// For strings.
  /// Each element of string_data is a UTF-8 encoded Unicode
  /// string. No trailing null, no leading BOM. The protobuf "string"
  /// scalar type is not used to match ML community conventions.
  /// When this field is present, the data_type field MUST be STRING
  var stringData: [Data] = []

  /// For int64.
  /// When this field is present, the data_type field MUST be INT64
  var int64Data: [Int64] = []

  /// Optionally, a name for the tensor.
  var name: String = String()

  /// A human-readable documentation for this tensor. Markdown is allowed.
  var docString: String = String()

  /// Serializations can either use one of the fields above, or use this
  /// raw bytes field. The only exception is the string case, where one is
  /// required to store the content in the repeated bytes string_data field.
  ///
  /// When this raw_data field is used to store tensor value, elements MUST
  /// be stored in as fixed-width, little-endian order.
  /// Floating-point data types MUST be stored in IEEE 754 format.
  /// Complex64 elements must be written as two consecutive FLOAT values, real component first.
  /// Complex128 elements must be written as two consecutive DOUBLE values, real component first.
  /// Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
  ///
  /// Note: the advantage of specific field rather than the raw_data field is
  /// that in some cases (e.g. int data), protobuf does a better packing via
  /// variable length storage, and may lead to smaller binary footprint.
  /// When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
  var rawData: Data = Data()

  /// Data can be stored inside the protobuf file using type-specific fields or raw_data.
  /// Alternatively, raw bytes data can be stored in an external file, using the external_data field.
  /// external_data stores key-value pairs describing data location. Recognized keys are:
  /// - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
  ///                           protobuf model was stored
  /// - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
  ///                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
  /// - "length" (optional) - number of bytes containing data. Integer stored as string.
  /// - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
  var externalData: [Onnx_StringStringEntryProto] = []

  /// If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
  var dataLocation: Onnx_TensorProto.DataLocation = .default

  /// For double
  /// Complex128 tensors are encoded as a single array of doubles,
  /// with the real components appearing in odd numbered positions,
  /// and the corresponding imaginary component appearing in the
  /// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
  /// is encoded as [1.0, 2.0 ,3.0 ,4.0]
  /// When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
  var doubleData: [Double] = []

  /// For uint64 and uint32 values
  /// When this field is present, the data_type field MUST be
  /// UINT32 or UINT64
  var uint64Data: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DataType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case undefined // = 0

    /// Basic types.
    case float // = 1

    /// uint8_t
    case uint8 // = 2

    /// int8_t
    case int8 // = 3

    /// uint16_t
    case uint16 // = 4

    /// int16_t
    case int16 // = 5

    /// int32_t
    case int32 // = 6

    /// int64_t
    case int64 // = 7

    /// string
    case string // = 8

    /// bool
    case bool // = 9

    /// IEEE754 half-precision floating-point format (16 bits wide).
    /// This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
    case float16 // = 10
    case double // = 11
    case uint32 // = 12
    case uint64 // = 13

    /// complex with float32 real and imaginary components
    case complex64 // = 14

    /// complex with float64 real and imaginary components
    case complex128 // = 15

    /// Non-IEEE floating-point format based on IEEE754 single-precision
    /// floating-point number truncated to 16 bits.
    /// This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
    case bfloat16 // = 16
    case UNRECOGNIZED(Int)

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .float
      case 2: self = .uint8
      case 3: self = .int8
      case 4: self = .uint16
      case 5: self = .int16
      case 6: self = .int32
      case 7: self = .int64
      case 8: self = .string
      case 9: self = .bool
      case 10: self = .float16
      case 11: self = .double
      case 12: self = .uint32
      case 13: self = .uint64
      case 14: self = .complex64
      case 15: self = .complex128
      case 16: self = .bfloat16
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .float: return 1
      case .uint8: return 2
      case .int8: return 3
      case .uint16: return 4
      case .int16: return 5
      case .int32: return 6
      case .int64: return 7
      case .string: return 8
      case .bool: return 9
      case .float16: return 10
      case .double: return 11
      case .uint32: return 12
      case .uint64: return 13
      case .complex64: return 14
      case .complex128: return 15
      case .bfloat16: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Location of the data for this tensor. MUST be one of:
  /// - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
  /// - EXTERNAL - data stored in an external location as described by external_data field.
  enum DataLocation: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case external // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .external
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .external: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// For very large tensors, we may want to store them in chunks, in which
  /// case the following fields will specify the segment that is stored in
  /// the current TensorProto.
  struct Segment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var begin: Int64 = 0

    var end: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _segment: Onnx_TensorProto.Segment? = nil
}

#if swift(>=4.2)

extension Onnx_TensorProto.DataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Onnx_TensorProto.DataType] = [
    .undefined,
    .float,
    .uint8,
    .int8,
    .uint16,
    .int16,
    .int32,
    .int64,
    .string,
    .bool,
    .float16,
    .double,
    .uint32,
    .uint64,
    .complex64,
    .complex128,
    .bfloat16,
  ]
}

extension Onnx_TensorProto.DataLocation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Onnx_TensorProto.DataLocation] = [
    .default,
    .external,
  ]
}

#endif  // swift(>=4.2)

/// A serialized sparse-tensor value
struct Onnx_SparseTensorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The sequence of non-default values are encoded as a tensor of shape [NNZ].
  /// The default-value is zero for numeric tensors, and empty-string for string tensors.
  /// values must have a non-empty name present which serves as a name for SparseTensorProto
  /// when used in sparse_initializer list.
  var values: Onnx_TensorProto {
    get {return _storage._values ?? Onnx_TensorProto()}
    set {_uniqueStorage()._values = newValue}
  }
  /// Returns true if `values` has been explicitly set.
  var hasValues: Bool {return _storage._values != nil}
  /// Clears the value of `values`. Subsequent reads from it will return its default value.
  mutating func clearValues() {_uniqueStorage()._values = nil}

  /// The indices of the non-default values, which may be stored in one of two formats.
  /// (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
  /// corresponding to the j-th index of the i-th value (in the values tensor).
  /// (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
  /// must be the linearized-index of the i-th value (in the values tensor).
  /// The linearized-index can be converted into an index tuple (k_1,...,k_rank)
  /// using the shape provided below.
  /// The indices must appear in ascending order without duplication.
  /// In the first format, the ordering is lexicographic-ordering:
  /// e.g., index-value [1,4] must appear before [2,1]
  var indices: Onnx_TensorProto {
    get {return _storage._indices ?? Onnx_TensorProto()}
    set {_uniqueStorage()._indices = newValue}
  }
  /// Returns true if `indices` has been explicitly set.
  var hasIndices: Bool {return _storage._indices != nil}
  /// Clears the value of `indices`. Subsequent reads from it will return its default value.
  mutating func clearIndices() {_uniqueStorage()._indices = nil}

  /// The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
  var dims: [Int64] {
    get {return _storage._dims}
    set {_uniqueStorage()._dims = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Defines a tensor shape. A dimension can be either an integer value
/// or a symbolic variable. A symbolic variable represents an unknown
/// dimension.
struct Onnx_TensorShapeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dim: [Onnx_TensorShapeProto.Dimension] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Dimension {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Onnx_TensorShapeProto.Dimension.OneOf_Value? = nil

    var dimValue: Int64 {
      get {
        if case .dimValue(let v)? = value {return v}
        return 0
      }
      set {value = .dimValue(newValue)}
    }

    /// namespace Shape
    var dimParam: String {
      get {
        if case .dimParam(let v)? = value {return v}
        return String()
      }
      set {value = .dimParam(newValue)}
    }

    /// Standard denotation can optionally be used to denote tensor
    /// dimensions with standard semantic descriptions to ensure
    /// that operations are applied to the correct axis of a tensor.
    /// Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
    /// for pre-defined dimension denotations.
    var denotation: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Value: Equatable {
      case dimValue(Int64)
      /// namespace Shape
      case dimParam(String)

    #if !swift(>=4.1)
      static func ==(lhs: Onnx_TensorShapeProto.Dimension.OneOf_Value, rhs: Onnx_TensorShapeProto.Dimension.OneOf_Value) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.dimValue, .dimValue): return {
          guard case .dimValue(let l) = lhs, case .dimValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.dimParam, .dimParam): return {
          guard case .dimParam(let l) = lhs, case .dimParam(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}
}

/// Types
///
/// The standard ONNX data types.
struct Onnx_TypeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// The type of a tensor.
  var tensorType: Onnx_TypeProto.Tensor {
    get {
      if case .tensorType(let v)? = _storage._value {return v}
      return Onnx_TypeProto.Tensor()
    }
    set {_uniqueStorage()._value = .tensorType(newValue)}
  }

  /// The type of a sequence.
  var sequenceType: Onnx_TypeProto.Sequence {
    get {
      if case .sequenceType(let v)? = _storage._value {return v}
      return Onnx_TypeProto.Sequence()
    }
    set {_uniqueStorage()._value = .sequenceType(newValue)}
  }

  /// The type of a map.
  var mapType: Onnx_TypeProto.Map {
    get {
      if case .mapType(let v)? = _storage._value {return v}
      return Onnx_TypeProto.Map()
    }
    set {_uniqueStorage()._value = .mapType(newValue)}
  }

  /// The type of an optional.
  var optionalType: Onnx_TypeProto.Optional {
    get {
      if case .optionalType(let v)? = _storage._value {return v}
      return Onnx_TypeProto.Optional()
    }
    set {_uniqueStorage()._value = .optionalType(newValue)}
  }

  /// Type of the sparse tensor
  var sparseTensorType: Onnx_TypeProto.SparseTensor {
    get {
      if case .sparseTensorType(let v)? = _storage._value {return v}
      return Onnx_TypeProto.SparseTensor()
    }
    set {_uniqueStorage()._value = .sparseTensorType(newValue)}
  }

  /// An optional denotation can be used to denote the whole
  /// type with a standard semantic description as to what is
  /// stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
  /// for pre-defined type denotations.
  var denotation: String {
    get {return _storage._denotation}
    set {_uniqueStorage()._denotation = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    /// The type of a tensor.
    case tensorType(Onnx_TypeProto.Tensor)
    /// The type of a sequence.
    case sequenceType(Onnx_TypeProto.Sequence)
    /// The type of a map.
    case mapType(Onnx_TypeProto.Map)
    /// The type of an optional.
    case optionalType(Onnx_TypeProto.Optional)
    /// Type of the sparse tensor
    case sparseTensorType(Onnx_TypeProto.SparseTensor)

  #if !swift(>=4.1)
    static func ==(lhs: Onnx_TypeProto.OneOf_Value, rhs: Onnx_TypeProto.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tensorType, .tensorType): return {
        guard case .tensorType(let l) = lhs, case .tensorType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sequenceType, .sequenceType): return {
        guard case .sequenceType(let l) = lhs, case .sequenceType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mapType, .mapType): return {
        guard case .mapType(let l) = lhs, case .mapType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.optionalType, .optionalType): return {
        guard case .optionalType(let l) = lhs, case .optionalType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sparseTensorType, .sparseTensorType): return {
        guard case .sparseTensorType(let l) = lhs, case .sparseTensorType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Tensor {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This field MUST NOT have the value of UNDEFINED
    /// This field MUST have a valid TensorProto.DataType value
    /// This field MUST be present for this version of the IR.
    var elemType: Int32 = 0

    var shape: Onnx_TensorShapeProto {
      get {return _shape ?? Onnx_TensorShapeProto()}
      set {_shape = newValue}
    }
    /// Returns true if `shape` has been explicitly set.
    var hasShape: Bool {return self._shape != nil}
    /// Clears the value of `shape`. Subsequent reads from it will return its default value.
    mutating func clearShape() {self._shape = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _shape: Onnx_TensorShapeProto? = nil
  }

  /// repeated T
  struct Sequence {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type and optional shape of each element of the sequence.
    /// This field MUST be present for this version of the IR.
    var elemType: Onnx_TypeProto {
      get {return _storage._elemType ?? Onnx_TypeProto()}
      set {_uniqueStorage()._elemType = newValue}
    }
    /// Returns true if `elemType` has been explicitly set.
    var hasElemType: Bool {return _storage._elemType != nil}
    /// Clears the value of `elemType`. Subsequent reads from it will return its default value.
    mutating func clearElemType() {_uniqueStorage()._elemType = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// map<K,V>
  struct Map {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This field MUST have a valid TensorProto.DataType value
    /// This field MUST be present for this version of the IR.
    /// This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
    var keyType: Int32 {
      get {return _storage._keyType}
      set {_uniqueStorage()._keyType = newValue}
    }

    /// This field MUST be present for this version of the IR.
    var valueType: Onnx_TypeProto {
      get {return _storage._valueType ?? Onnx_TypeProto()}
      set {_uniqueStorage()._valueType = newValue}
    }
    /// Returns true if `valueType` has been explicitly set.
    var hasValueType: Bool {return _storage._valueType != nil}
    /// Clears the value of `valueType`. Subsequent reads from it will return its default value.
    mutating func clearValueType() {_uniqueStorage()._valueType = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// wrapper for Tensor, Sequence, or Map
  struct Optional {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type and optional shape of the element wrapped.
    /// This field MUST be present for this version of the IR.
    /// Possible values correspond to OptionalProto.DataType enum
    var elemType: Onnx_TypeProto {
      get {return _storage._elemType ?? Onnx_TypeProto()}
      set {_uniqueStorage()._elemType = newValue}
    }
    /// Returns true if `elemType` has been explicitly set.
    var hasElemType: Bool {return _storage._elemType != nil}
    /// Clears the value of `elemType`. Subsequent reads from it will return its default value.
    mutating func clearElemType() {_uniqueStorage()._elemType = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct SparseTensor {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This field MUST NOT have the value of UNDEFINED
    /// This field MUST have a valid TensorProto.DataType value
    /// This field MUST be present for this version of the IR.
    var elemType: Int32 = 0

    var shape: Onnx_TensorShapeProto {
      get {return _shape ?? Onnx_TensorShapeProto()}
      set {_shape = newValue}
    }
    /// Returns true if `shape` has been explicitly set.
    var hasShape: Bool {return self._shape != nil}
    /// Clears the value of `shape`. Subsequent reads from it will return its default value.
    mutating func clearShape() {self._shape = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _shape: Onnx_TensorShapeProto? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Operator Sets
///
/// OperatorSets are uniquely identified by a (domain, opset_version) pair.
struct Onnx_OperatorSetIdProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The domain of the operator set being identified.
  /// The empty string ("") or absence of this field implies the operator
  /// set that is defined as part of the ONNX specification.
  /// This field MUST be present in this version of the IR when referring to any other operator set.
  var domain: String = String()

  /// The version of the operator set being identified.
  /// This field MUST be present in this version of the IR.
  var version: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Onnx_FunctionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the function, similar usage of op_type in OperatorProto.
  /// Combined with FunctionProto.domain, this forms the unique identity of
  /// the FunctionProto.
  var name: String = String()

  /// The inputs and outputs of the function.
  var input: [String] = []

  var output: [String] = []

  /// The attributes of the function.
  var attribute: [String] = []

  /// The nodes in the function.
  var node: [Onnx_NodeProto] = []

  /// A human-readable documentation for this function. Markdown is allowed.
  var docString: String = String()

  var opsetImport: [Onnx_OperatorSetIdProto] = []

  /// The domain which this function belongs to. Combined with FunctionProto.name, this forms the unique identity of
  /// the FunctionProto.
  var domain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "onnx"

extension Onnx_Version: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "_START_VERSION"),
    1: .same(proto: "IR_VERSION_2017_10_10"),
    2: .same(proto: "IR_VERSION_2017_10_30"),
    3: .same(proto: "IR_VERSION_2017_11_3"),
    4: .same(proto: "IR_VERSION_2019_1_22"),
    5: .same(proto: "IR_VERSION_2019_3_18"),
    6: .same(proto: "IR_VERSION_2019_9_19"),
    7: .same(proto: "IR_VERSION_2020_5_8"),
    8: .same(proto: "IR_VERSION"),
  ]
}

extension Onnx_OperatorStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXPERIMENTAL"),
    1: .same(proto: "STABLE"),
  ]
}

extension Onnx_AttributeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttributeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    21: .standard(proto: "ref_attr_name"),
    13: .standard(proto: "doc_string"),
    20: .same(proto: "type"),
    2: .same(proto: "f"),
    3: .same(proto: "i"),
    4: .same(proto: "s"),
    5: .same(proto: "t"),
    6: .same(proto: "g"),
    22: .standard(proto: "sparse_tensor"),
    14: .same(proto: "tp"),
    7: .same(proto: "floats"),
    8: .same(proto: "ints"),
    9: .same(proto: "strings"),
    10: .same(proto: "tensors"),
    11: .same(proto: "graphs"),
    23: .standard(proto: "sparse_tensors"),
    15: .standard(proto: "type_protos"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _refAttrName: String = String()
    var _docString: String = String()
    var _type: Onnx_AttributeProto.AttributeType = .undefined
    var _f: Float = 0
    var _i: Int64 = 0
    var _s: Data = Data()
    var _t: Onnx_TensorProto? = nil
    var _g: Onnx_GraphProto? = nil
    var _sparseTensor: Onnx_SparseTensorProto? = nil
    var _tp: Onnx_TypeProto? = nil
    var _floats: [Float] = []
    var _ints: [Int64] = []
    var _strings: [Data] = []
    var _tensors: [Onnx_TensorProto] = []
    var _graphs: [Onnx_GraphProto] = []
    var _sparseTensors: [Onnx_SparseTensorProto] = []
    var _typeProtos: [Onnx_TypeProto] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _refAttrName = source._refAttrName
      _docString = source._docString
      _type = source._type
      _f = source._f
      _i = source._i
      _s = source._s
      _t = source._t
      _g = source._g
      _sparseTensor = source._sparseTensor
      _tp = source._tp
      _floats = source._floats
      _ints = source._ints
      _strings = source._strings
      _tensors = source._tensors
      _graphs = source._graphs
      _sparseTensors = source._sparseTensors
      _typeProtos = source._typeProtos
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._f) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._i) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._s) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._t) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._g) }()
        case 7: try { try decoder.decodeRepeatedFloatField(value: &_storage._floats) }()
        case 8: try { try decoder.decodeRepeatedInt64Field(value: &_storage._ints) }()
        case 9: try { try decoder.decodeRepeatedBytesField(value: &_storage._strings) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._tensors) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._graphs) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._docString) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._tp) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._typeProtos) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._refAttrName) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._sparseTensor) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._sparseTensors) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if _storage._f != 0 {
        try visitor.visitSingularFloatField(value: _storage._f, fieldNumber: 2)
      }
      if _storage._i != 0 {
        try visitor.visitSingularInt64Field(value: _storage._i, fieldNumber: 3)
      }
      if !_storage._s.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._s, fieldNumber: 4)
      }
      try { if let v = _storage._t {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._g {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._floats.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._floats, fieldNumber: 7)
      }
      if !_storage._ints.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._ints, fieldNumber: 8)
      }
      if !_storage._strings.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._strings, fieldNumber: 9)
      }
      if !_storage._tensors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tensors, fieldNumber: 10)
      }
      if !_storage._graphs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._graphs, fieldNumber: 11)
      }
      if !_storage._docString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._docString, fieldNumber: 13)
      }
      try { if let v = _storage._tp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._typeProtos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._typeProtos, fieldNumber: 15)
      }
      if _storage._type != .undefined {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 20)
      }
      if !_storage._refAttrName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._refAttrName, fieldNumber: 21)
      }
      try { if let v = _storage._sparseTensor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._sparseTensors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sparseTensors, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_AttributeProto, rhs: Onnx_AttributeProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._refAttrName != rhs_storage._refAttrName {return false}
        if _storage._docString != rhs_storage._docString {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._f != rhs_storage._f {return false}
        if _storage._i != rhs_storage._i {return false}
        if _storage._s != rhs_storage._s {return false}
        if _storage._t != rhs_storage._t {return false}
        if _storage._g != rhs_storage._g {return false}
        if _storage._sparseTensor != rhs_storage._sparseTensor {return false}
        if _storage._tp != rhs_storage._tp {return false}
        if _storage._floats != rhs_storage._floats {return false}
        if _storage._ints != rhs_storage._ints {return false}
        if _storage._strings != rhs_storage._strings {return false}
        if _storage._tensors != rhs_storage._tensors {return false}
        if _storage._graphs != rhs_storage._graphs {return false}
        if _storage._sparseTensors != rhs_storage._sparseTensors {return false}
        if _storage._typeProtos != rhs_storage._typeProtos {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_AttributeProto.AttributeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "FLOAT"),
    2: .same(proto: "INT"),
    3: .same(proto: "STRING"),
    4: .same(proto: "TENSOR"),
    5: .same(proto: "GRAPH"),
    6: .same(proto: "FLOATS"),
    7: .same(proto: "INTS"),
    8: .same(proto: "STRINGS"),
    9: .same(proto: "TENSORS"),
    10: .same(proto: "GRAPHS"),
    11: .same(proto: "SPARSE_TENSOR"),
    12: .same(proto: "SPARSE_TENSORS"),
    13: .same(proto: "TYPE_PROTO"),
    14: .same(proto: "TYPE_PROTOS"),
  ]
}

extension Onnx_ValueInfoProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValueInfoProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .standard(proto: "doc_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_ValueInfoProto, rhs: Onnx_ValueInfoProto) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._type != rhs._type {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_NodeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "output"),
    3: .same(proto: "name"),
    4: .standard(proto: "op_type"),
    7: .same(proto: "domain"),
    5: .same(proto: "attribute"),
    6: .standard(proto: "doc_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.input) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.output) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.opType) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.attribute) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.input.isEmpty {
      try visitor.visitRepeatedStringField(value: self.input, fieldNumber: 1)
    }
    if !self.output.isEmpty {
      try visitor.visitRepeatedStringField(value: self.output, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.opType.isEmpty {
      try visitor.visitSingularStringField(value: self.opType, fieldNumber: 4)
    }
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 5)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 6)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_NodeProto, rhs: Onnx_NodeProto) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.output != rhs.output {return false}
    if lhs.name != rhs.name {return false}
    if lhs.opType != rhs.opType {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TrainingInfoProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrainingInfoProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initialization"),
    2: .same(proto: "algorithm"),
    3: .standard(proto: "initialization_binding"),
    4: .standard(proto: "update_binding"),
  ]

  fileprivate class _StorageClass {
    var _initialization: Onnx_GraphProto? = nil
    var _algorithm: Onnx_GraphProto? = nil
    var _initializationBinding: [Onnx_StringStringEntryProto] = []
    var _updateBinding: [Onnx_StringStringEntryProto] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _initialization = source._initialization
      _algorithm = source._algorithm
      _initializationBinding = source._initializationBinding
      _updateBinding = source._updateBinding
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._initialization) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._algorithm) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._initializationBinding) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._updateBinding) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._initialization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._algorithm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._initializationBinding.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._initializationBinding, fieldNumber: 3)
      }
      if !_storage._updateBinding.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._updateBinding, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TrainingInfoProto, rhs: Onnx_TrainingInfoProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._initialization != rhs_storage._initialization {return false}
        if _storage._algorithm != rhs_storage._algorithm {return false}
        if _storage._initializationBinding != rhs_storage._initializationBinding {return false}
        if _storage._updateBinding != rhs_storage._updateBinding {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_ModelProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModelProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ir_version"),
    8: .standard(proto: "opset_import"),
    2: .standard(proto: "producer_name"),
    3: .standard(proto: "producer_version"),
    4: .same(proto: "domain"),
    5: .standard(proto: "model_version"),
    6: .standard(proto: "doc_string"),
    7: .same(proto: "graph"),
    14: .standard(proto: "metadata_props"),
    20: .standard(proto: "training_info"),
    25: .same(proto: "functions"),
  ]

  fileprivate class _StorageClass {
    var _irVersion: Int64 = 0
    var _opsetImport: [Onnx_OperatorSetIdProto] = []
    var _producerName: String = String()
    var _producerVersion: String = String()
    var _domain: String = String()
    var _modelVersion: Int64 = 0
    var _docString: String = String()
    var _graph: Onnx_GraphProto? = nil
    var _metadataProps: [Onnx_StringStringEntryProto] = []
    var _trainingInfo: [Onnx_TrainingInfoProto] = []
    var _functions: [Onnx_FunctionProto] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _irVersion = source._irVersion
      _opsetImport = source._opsetImport
      _producerName = source._producerName
      _producerVersion = source._producerVersion
      _domain = source._domain
      _modelVersion = source._modelVersion
      _docString = source._docString
      _graph = source._graph
      _metadataProps = source._metadataProps
      _trainingInfo = source._trainingInfo
      _functions = source._functions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._irVersion) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._producerName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._producerVersion) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._domain) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._modelVersion) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._docString) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._graph) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._opsetImport) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._metadataProps) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._trainingInfo) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._functions) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._irVersion != 0 {
        try visitor.visitSingularInt64Field(value: _storage._irVersion, fieldNumber: 1)
      }
      if !_storage._producerName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._producerName, fieldNumber: 2)
      }
      if !_storage._producerVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._producerVersion, fieldNumber: 3)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 4)
      }
      if _storage._modelVersion != 0 {
        try visitor.visitSingularInt64Field(value: _storage._modelVersion, fieldNumber: 5)
      }
      if !_storage._docString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._docString, fieldNumber: 6)
      }
      try { if let v = _storage._graph {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._opsetImport.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._opsetImport, fieldNumber: 8)
      }
      if !_storage._metadataProps.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._metadataProps, fieldNumber: 14)
      }
      if !_storage._trainingInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._trainingInfo, fieldNumber: 20)
      }
      if !_storage._functions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._functions, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_ModelProto, rhs: Onnx_ModelProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._irVersion != rhs_storage._irVersion {return false}
        if _storage._opsetImport != rhs_storage._opsetImport {return false}
        if _storage._producerName != rhs_storage._producerName {return false}
        if _storage._producerVersion != rhs_storage._producerVersion {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._modelVersion != rhs_storage._modelVersion {return false}
        if _storage._docString != rhs_storage._docString {return false}
        if _storage._graph != rhs_storage._graph {return false}
        if _storage._metadataProps != rhs_storage._metadataProps {return false}
        if _storage._trainingInfo != rhs_storage._trainingInfo {return false}
        if _storage._functions != rhs_storage._functions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_StringStringEntryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringStringEntryProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_StringStringEntryProto, rhs: Onnx_StringStringEntryProto) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TensorAnnotation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tensor_name"),
    2: .standard(proto: "quant_parameter_tensor_names"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tensorName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.quantParameterTensorNames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tensorName.isEmpty {
      try visitor.visitSingularStringField(value: self.tensorName, fieldNumber: 1)
    }
    if !self.quantParameterTensorNames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quantParameterTensorNames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TensorAnnotation, rhs: Onnx_TensorAnnotation) -> Bool {
    if lhs.tensorName != rhs.tensorName {return false}
    if lhs.quantParameterTensorNames != rhs.quantParameterTensorNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_GraphProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GraphProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    2: .same(proto: "name"),
    5: .same(proto: "initializer"),
    15: .standard(proto: "sparse_initializer"),
    10: .standard(proto: "doc_string"),
    11: .same(proto: "input"),
    12: .same(proto: "output"),
    13: .standard(proto: "value_info"),
    14: .standard(proto: "quantization_annotation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.node) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.initializer) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.input) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.output) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.valueInfo) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.quantizationAnnotation) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.sparseInitializer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.node.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.node, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.initializer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.initializer, fieldNumber: 5)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 10)
    }
    if !self.input.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.input, fieldNumber: 11)
    }
    if !self.output.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.output, fieldNumber: 12)
    }
    if !self.valueInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valueInfo, fieldNumber: 13)
    }
    if !self.quantizationAnnotation.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quantizationAnnotation, fieldNumber: 14)
    }
    if !self.sparseInitializer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sparseInitializer, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_GraphProto, rhs: Onnx_GraphProto) -> Bool {
    if lhs.node != rhs.node {return false}
    if lhs.name != rhs.name {return false}
    if lhs.initializer != rhs.initializer {return false}
    if lhs.sparseInitializer != rhs.sparseInitializer {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.input != rhs.input {return false}
    if lhs.output != rhs.output {return false}
    if lhs.valueInfo != rhs.valueInfo {return false}
    if lhs.quantizationAnnotation != rhs.quantizationAnnotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TensorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dims"),
    2: .standard(proto: "data_type"),
    3: .same(proto: "segment"),
    4: .standard(proto: "float_data"),
    5: .standard(proto: "int32_data"),
    6: .standard(proto: "string_data"),
    7: .standard(proto: "int64_data"),
    8: .same(proto: "name"),
    12: .standard(proto: "doc_string"),
    9: .standard(proto: "raw_data"),
    13: .standard(proto: "external_data"),
    14: .standard(proto: "data_location"),
    10: .standard(proto: "double_data"),
    11: .standard(proto: "uint64_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.dims) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.dataType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._segment) }()
      case 4: try { try decoder.decodeRepeatedFloatField(value: &self.floatData) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.int32Data) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.stringData) }()
      case 7: try { try decoder.decodeRepeatedInt64Field(value: &self.int64Data) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.rawData) }()
      case 10: try { try decoder.decodeRepeatedDoubleField(value: &self.doubleData) }()
      case 11: try { try decoder.decodeRepeatedUInt64Field(value: &self.uint64Data) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.externalData) }()
      case 14: try { try decoder.decodeSingularEnumField(value: &self.dataLocation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.dims.isEmpty {
      try visitor.visitPackedInt64Field(value: self.dims, fieldNumber: 1)
    }
    if self.dataType != 0 {
      try visitor.visitSingularInt32Field(value: self.dataType, fieldNumber: 2)
    }
    try { if let v = self._segment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.floatData.isEmpty {
      try visitor.visitPackedFloatField(value: self.floatData, fieldNumber: 4)
    }
    if !self.int32Data.isEmpty {
      try visitor.visitPackedInt32Field(value: self.int32Data, fieldNumber: 5)
    }
    if !self.stringData.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.stringData, fieldNumber: 6)
    }
    if !self.int64Data.isEmpty {
      try visitor.visitPackedInt64Field(value: self.int64Data, fieldNumber: 7)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 8)
    }
    if !self.rawData.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawData, fieldNumber: 9)
    }
    if !self.doubleData.isEmpty {
      try visitor.visitPackedDoubleField(value: self.doubleData, fieldNumber: 10)
    }
    if !self.uint64Data.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.uint64Data, fieldNumber: 11)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 12)
    }
    if !self.externalData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.externalData, fieldNumber: 13)
    }
    if self.dataLocation != .default {
      try visitor.visitSingularEnumField(value: self.dataLocation, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TensorProto, rhs: Onnx_TensorProto) -> Bool {
    if lhs.dims != rhs.dims {return false}
    if lhs.dataType != rhs.dataType {return false}
    if lhs._segment != rhs._segment {return false}
    if lhs.floatData != rhs.floatData {return false}
    if lhs.int32Data != rhs.int32Data {return false}
    if lhs.stringData != rhs.stringData {return false}
    if lhs.int64Data != rhs.int64Data {return false}
    if lhs.name != rhs.name {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.rawData != rhs.rawData {return false}
    if lhs.externalData != rhs.externalData {return false}
    if lhs.dataLocation != rhs.dataLocation {return false}
    if lhs.doubleData != rhs.doubleData {return false}
    if lhs.uint64Data != rhs.uint64Data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorProto.DataType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "FLOAT"),
    2: .same(proto: "UINT8"),
    3: .same(proto: "INT8"),
    4: .same(proto: "UINT16"),
    5: .same(proto: "INT16"),
    6: .same(proto: "INT32"),
    7: .same(proto: "INT64"),
    8: .same(proto: "STRING"),
    9: .same(proto: "BOOL"),
    10: .same(proto: "FLOAT16"),
    11: .same(proto: "DOUBLE"),
    12: .same(proto: "UINT32"),
    13: .same(proto: "UINT64"),
    14: .same(proto: "COMPLEX64"),
    15: .same(proto: "COMPLEX128"),
    16: .same(proto: "BFLOAT16"),
  ]
}

extension Onnx_TensorProto.DataLocation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "EXTERNAL"),
  ]
}

extension Onnx_TensorProto.Segment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Onnx_TensorProto.protoMessageName + ".Segment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "begin"),
    2: .same(proto: "end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.begin) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.end) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.begin != 0 {
      try visitor.visitSingularInt64Field(value: self.begin, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TensorProto.Segment, rhs: Onnx_TensorProto.Segment) -> Bool {
    if lhs.begin != rhs.begin {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_SparseTensorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SparseTensorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "indices"),
    3: .same(proto: "dims"),
  ]

  fileprivate class _StorageClass {
    var _values: Onnx_TensorProto? = nil
    var _indices: Onnx_TensorProto? = nil
    var _dims: [Int64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _values = source._values
      _indices = source._indices
      _dims = source._dims
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._values) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._indices) }()
        case 3: try { try decoder.decodeRepeatedInt64Field(value: &_storage._dims) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._values {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._indices {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._dims.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._dims, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_SparseTensorProto, rhs: Onnx_SparseTensorProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._values != rhs_storage._values {return false}
        if _storage._indices != rhs_storage._indices {return false}
        if _storage._dims != rhs_storage._dims {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorShapeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TensorShapeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dim"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dim) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dim.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dim, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TensorShapeProto, rhs: Onnx_TensorShapeProto) -> Bool {
    if lhs.dim != rhs.dim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorShapeProto.Dimension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Onnx_TensorShapeProto.protoMessageName + ".Dimension"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dim_value"),
    2: .standard(proto: "dim_param"),
    3: .same(proto: "denotation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .dimValue(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .dimParam(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.denotation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .dimValue?: try {
      guard case .dimValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }()
    case .dimParam?: try {
      guard case .dimParam(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.denotation.isEmpty {
      try visitor.visitSingularStringField(value: self.denotation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TensorShapeProto.Dimension, rhs: Onnx_TensorShapeProto.Dimension) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.denotation != rhs.denotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tensor_type"),
    4: .standard(proto: "sequence_type"),
    5: .standard(proto: "map_type"),
    9: .standard(proto: "optional_type"),
    8: .standard(proto: "sparse_tensor_type"),
    6: .same(proto: "denotation"),
  ]

  fileprivate class _StorageClass {
    var _value: Onnx_TypeProto.OneOf_Value?
    var _denotation: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _denotation = source._denotation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Onnx_TypeProto.Tensor?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .tensorType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .tensorType(v)
          }
        }()
        case 4: try {
          var v: Onnx_TypeProto.Sequence?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .sequenceType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .sequenceType(v)
          }
        }()
        case 5: try {
          var v: Onnx_TypeProto.Map?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .mapType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .mapType(v)
          }
        }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._denotation) }()
        case 8: try {
          var v: Onnx_TypeProto.SparseTensor?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .sparseTensorType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .sparseTensorType(v)
          }
        }()
        case 9: try {
          var v: Onnx_TypeProto.Optional?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .optionalType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .optionalType(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._value {
      case .tensorType?: try {
        guard case .tensorType(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .sequenceType?: try {
        guard case .sequenceType(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .mapType?: try {
        guard case .mapType(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      default: break
      }
      if !_storage._denotation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._denotation, fieldNumber: 6)
      }
      switch _storage._value {
      case .sparseTensorType?: try {
        guard case .sparseTensorType(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .optionalType?: try {
        guard case .optionalType(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TypeProto, rhs: Onnx_TypeProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._denotation != rhs_storage._denotation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto.Tensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Onnx_TypeProto.protoMessageName + ".Tensor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "elem_type"),
    2: .same(proto: "shape"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.elemType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shape) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.elemType != 0 {
      try visitor.visitSingularInt32Field(value: self.elemType, fieldNumber: 1)
    }
    try { if let v = self._shape {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TypeProto.Tensor, rhs: Onnx_TypeProto.Tensor) -> Bool {
    if lhs.elemType != rhs.elemType {return false}
    if lhs._shape != rhs._shape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto.Sequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Onnx_TypeProto.protoMessageName + ".Sequence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "elem_type"),
  ]

  fileprivate class _StorageClass {
    var _elemType: Onnx_TypeProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elemType = source._elemType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._elemType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._elemType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TypeProto.Sequence, rhs: Onnx_TypeProto.Sequence) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elemType != rhs_storage._elemType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto.Map: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Onnx_TypeProto.protoMessageName + ".Map"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_type"),
    2: .standard(proto: "value_type"),
  ]

  fileprivate class _StorageClass {
    var _keyType: Int32 = 0
    var _valueType: Onnx_TypeProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keyType = source._keyType
      _valueType = source._valueType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._keyType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._valueType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._keyType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._keyType, fieldNumber: 1)
      }
      try { if let v = _storage._valueType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TypeProto.Map, rhs: Onnx_TypeProto.Map) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keyType != rhs_storage._keyType {return false}
        if _storage._valueType != rhs_storage._valueType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto.Optional: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Onnx_TypeProto.protoMessageName + ".Optional"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "elem_type"),
  ]

  fileprivate class _StorageClass {
    var _elemType: Onnx_TypeProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elemType = source._elemType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._elemType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._elemType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TypeProto.Optional, rhs: Onnx_TypeProto.Optional) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elemType != rhs_storage._elemType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto.SparseTensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Onnx_TypeProto.protoMessageName + ".SparseTensor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "elem_type"),
    2: .same(proto: "shape"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.elemType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shape) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.elemType != 0 {
      try visitor.visitSingularInt32Field(value: self.elemType, fieldNumber: 1)
    }
    try { if let v = self._shape {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_TypeProto.SparseTensor, rhs: Onnx_TypeProto.SparseTensor) -> Bool {
    if lhs.elemType != rhs.elemType {return false}
    if lhs._shape != rhs._shape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_OperatorSetIdProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OperatorSetIdProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_OperatorSetIdProto, rhs: Onnx_OperatorSetIdProto) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_FunctionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    4: .same(proto: "input"),
    5: .same(proto: "output"),
    6: .same(proto: "attribute"),
    7: .same(proto: "node"),
    8: .standard(proto: "doc_string"),
    9: .standard(proto: "opset_import"),
    10: .same(proto: "domain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.input) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.output) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.attribute) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.node) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.opsetImport) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.input.isEmpty {
      try visitor.visitRepeatedStringField(value: self.input, fieldNumber: 4)
    }
    if !self.output.isEmpty {
      try visitor.visitRepeatedStringField(value: self.output, fieldNumber: 5)
    }
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedStringField(value: self.attribute, fieldNumber: 6)
    }
    if !self.node.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.node, fieldNumber: 7)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 8)
    }
    if !self.opsetImport.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.opsetImport, fieldNumber: 9)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Onnx_FunctionProto, rhs: Onnx_FunctionProto) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.input != rhs.input {return false}
    if lhs.output != rhs.output {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.node != rhs.node {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.opsetImport != rhs.opsetImport {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
